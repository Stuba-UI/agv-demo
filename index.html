<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGV Warehouse Simulation</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load THREE.js and OrbitControls for 3D visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for r128 is typically loaded this way for global availability -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* Ensure the body and containers use the full viewport height */
        body {
            font-family: 'Inter', sans-serif;
        }

        #viewer3d {
            min-height: 400px;
        }
        /* Custom scrollbar for better appearance */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #9ca3af;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 flex flex-col items-center">

    <div id="app" class="w-full max-w-6xl">
        <!-- Header and Controls -->
        <header class="bg-white p-4 rounded-xl shadow-lg mb-4 border-t-4 border-indigo-600">
            <h1 class="text-3xl font-extrabold text-indigo-800 mb-2">AGV Warehouse Simulator</h1>
            <p class="text-gray-500 text-sm">Design the layout, spawn AGVs, and run the automated simulation in 3D.</p>

            <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-3" id="controls-panel">
                <button id="spawn-agvs-btn"
                        class="col-span-2 md:col-span-1 p-3 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 transition-colors disabled:bg-gray-400">
                    Spawn AGV(s)
                </button>

                <button id="toggle-sim-btn"
                        class="col-span-2 md:col-span-1 p-3 font-bold rounded-lg shadow-md transition-colors disabled:bg-gray-400 bg-green-500 hover:bg-green-600 text-white">
                    ▶ Run Simulation
                </button>

                <div class="col-span-2 md:col-span-2 flex items-center space-x-2 bg-gray-100 p-2 rounded-lg">
                    <label class="text-sm font-semibold text-gray-600">Speed (ms):</label>
                    <input type="range"
                           id="speed-slider"
                           min="50"
                           max="1000"
                           value="300"
                           class="flex-grow h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer" />
                    <span id="speed-value" class="text-sm font-bold w-12 text-right">300ms</span>
                </div>
            </div>

            <!-- Stats / OPC-UA Tags Panel -->
            <div id="stats-panel" class="mt-4 border-t pt-3 grid grid-cols-2 md:grid-cols-4 gap-3 text-center">
                <div class="p-2 bg-indigo-50 rounded-lg">
                    <p class="text-xs text-indigo-500">AGVs Deployed</p>
                    <p id="stat-agv-count" class="text-2xl font-bold text-indigo-700">0</p>
                </div>
                <div class="p-2 bg-indigo-50 rounded-lg">
                    <p class="text-xs text-indigo-500">Warehouse Inventory (Units)</p>
                    <p id="stat-inventory" class="text-2xl font-bold text-indigo-700">0</p>
                </div>
                <div class="p-2 bg-indigo-50 rounded-lg">
                    <p class="text-xs text-indigo-500">Total Production</p>
                    <p id="stat-production" class="text-2xl font-bold text-indigo-700">0</p>
                </div>
                <div class="p-2 bg-indigo-50 rounded-lg">
                    <p class="text-xs text-indigo-500">Last Update</p>
                    <p id="stat-timestamp" class="text-xl font-bold text-indigo-700">--</p>
                </div>
            </div>

        </header>

        <!-- Main Viewport: 2D Grid & 3D Viewer -->
        <main class="flex flex-col lg:flex-row flex-grow min-h-[70vh] gap-4">

            <!-- Left Panel: 2D Grid & Placement Controls -->
            <div class="lg:w-1/2 flex flex-col bg-white p-4 rounded-xl shadow-lg border-t-4 border-gray-400">
                <h2 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">2D Warehouse Layout</h2>

                <!-- Placement Type Selector -->
                <div id="placement-selector" class="mb-4 grid grid-cols-3 gap-2">
                    <!-- Buttons generated by JS -->
                </div>

                <!-- The 2D Grid Container -->
                <div class="border-4 border-gray-400 rounded-lg p-1 bg-white shadow-inner flex-grow flex items-center justify-center overflow-auto">
                    <div id="grid-container" class="flex flex-col select-none">
                        <!-- Grid cells generated by JS -->
                    </div>
                </div>

                <!-- AGV Status List -->
                <div class="mt-4 space-y-2 max-h-40 overflow-y-auto">
                    <h3 class="text-sm font-bold text-gray-700 sticky top-0 bg-white">AGV Status (<span id="agv-count-status">0</span> Deployed)</h3>
                    <div id="agv-status-list">
                        <p class="text-sm text-gray-500 italic">Spawn AGVs at 'Start' locations to begin tracking.</p>
                    </div>
                </div>
            </div>

            <!-- Right Panel: 3D Viewer -->
            <div class="lg:w-1/2 flex flex-col bg-white p-4 rounded-xl shadow-lg border-t-4 border-gray-800">
                <h2 class="text-xl font-bold text-gray-800 mb-3 border-b pb-2">3D Visualization</h2>
                <div id="viewer3d" class="w-full h-full border-4 border-gray-800 rounded-lg shadow-2xl overflow-hidden bg-gray-200">
                    <!-- THREE.js canvas will be injected here -->
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // Mandatory Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Firestore is not strictly needed for this simulation but is included for compliance
        // import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration (Same as React Component) ---
        const GRID_SIZE = 20;
        const MAX_STACK_HEIGHT = 5;
        const CELL_SIZE = 1.0;
        const AGV_HEIGHT = 0.2;
        const PRODUCT_HEIGHT = 0.2;

        const CELL_TYPE = {
          PATH: { type: 0, class: 'bg-gray-100 hover:bg-gray-200', icon: '', label: 'Clear', color: 0xcccccc },
          OBSTACLE: { type: 1, class: 'bg-red-400 hover:bg-red-500', icon: '🧱', label: 'Obstacle', color: 0x880000 },
          START: { type: 2, class: 'bg-blue-300 hover:bg-blue-400', icon: '🤖', label: 'Start', color: 0x00aaff },
          PICKUP: { type: 3, class: 'bg-yellow-300 hover:bg-yellow-400', icon: '📦', label: 'Pickup', color: 0xffcc00 },
          DROPOFF: { type: 4, class: 'bg-purple-300 hover:bg-purple-400', icon: '🏭', label: 'Dropoff', color: 0xaa00ff },
        };

        const AGV_COLOR = {
          moving: 0x00ff00,
          waiting: 0xff3399,
          cargo: 0xff8c00,
        };

        const defaultGrid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL_TYPE.PATH.type));

        // --- Global State (Replaces React useState) ---
        let grid = JSON.parse(JSON.stringify(defaultGrid));
        let agvs = [];
        let mapElements = {
          starts: [],
          pickups: [],
          dropoffs: [],
        };
        let agvCounter = 0;
        let isRunning = false;
        let settings = {
          speed: 300,
          placementType: 'START'
        };
        let opcUaTags = {
            AGV_STATUS_COUNT: 0,
            WAREHOUSE_INVENTORY_LEVEL: 0,
            TOTAL_PRODUCTION_COUNT: 0,
            SIM_TIMESTAMP: new Date().toLocaleTimeString(),
        };
        let simIntervalId = null;

        // --- 3D Viewer References (Replaces React useRef) ---
        let scene, camera, renderer, controls;
        // Store references to THREE.js objects that are map elements or AGVs
        let elementsRef = new Map();

        // --- Utility Functions ---

        // Manhattan distance heuristic for A*
        const heuristic = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

        // A* Pathfinding (Simplified for grid movement)
        const aStar = (startX, startY, endX, endY, currentGrid, currentAgvs) => {
          const openList = [{ x: startX, y: startY, g: 0, h: heuristic(startX, startY, endX, endY), f: heuristic(startX, startY, endX, endY), parent: null }];
          const closedSet = [];

          while (openList.length > 0) {
            openList.sort((a, b) => a.f - b.f);
            const current = openList.shift();

            if (current.x === endX && current.y === endY) {
              const path = [];
              let temp = current;
              while (temp.parent) {
                path.push({ x: temp.x, y: temp.y });
                temp = temp.parent;
              }
              return path.reverse();
            }

            closedSet.push(current);

            const neighbors = [
              { x: current.x, y: current.y - 1 },
              { x: current.x, y: current.y + 1 },
              { x: current.x - 1, y: current.y },
              { x: current.x + 1, y: current.y }
            ];

            for (const neighbor of neighbors) {
              if (neighbor.x < 0 || neighbor.x >= GRID_SIZE || neighbor.y < 0 || neighbor.y >= GRID_SIZE) continue;
              if (currentGrid[neighbor.y][neighbor.x] === CELL_TYPE.OBSTACLE.type) continue;

              // Simple AGV collision check
              // Only check if the AGV is trying to move into a cell currently occupied by another AGV
              const existingAGVAtTarget = currentAgvs.some(agv => agv.x === neighbor.x && agv.y === neighbor.y);
              if (existingAGVAtTarget) continue;

              if (closedSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) continue;

              const g = current.g + 1;
              const h = heuristic(neighbor.x, neighbor.y, endX, endY);
              const f = g + h;

              const existing = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);

              if (!existing || g < existing.g) {
                if (existing) {
                  existing.g = g;
                  existing.f = f;
                  existing.parent = current;
                } else {
                  openList.push({ x: neighbor.x, y: neighbor.y, g, h, f, parent: current });
                }
              }
            }
          }
          return null;
        };

        // Function to convert grid coordinates to world coordinates
        const toWorld = (x, y, z = 0) => ({
            x: x * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE / 2,
            y: z,
            z: y * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE / 2,
        });

        // Helper to remove and dispose of a THREE.js object
        function removeAndDispose(key) {
             const obj = elementsRef.get(key);
             if (obj) {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                // If it's a group, dispose of children too
                if (obj.children) {
                     obj.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                     });
                }
                elementsRef.delete(key);
             }
        }

        // --- THREE.js Initialization and Update Functions ---

        function initThreeDViewer() {
            const mount = document.getElementById('viewer3d');
            if (typeof THREE === 'undefined') {
                mount.innerHTML = `<div class="flex items-center justify-center w-full h-full text-red-700 font-bold p-4 bg-red-100">Error: THREE.js library not found. 3D visualization cannot be rendered.</div>`;
                return;
            }

            const width = GRID_SIZE * CELL_SIZE;
            const height = GRID_SIZE * CELL_SIZE;

            // SCENE SETUP
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // CAMERA SETUP
            camera = new THREE.PerspectiveCamera(75, mount.clientWidth / mount.clientHeight, 0.1, 1000);
            camera.position.set(width / 2, 15, height / 2 + 5);
            camera.lookAt(0, 0, 0);

            // RENDERER SETUP
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(mount.clientWidth, mount.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            mount.appendChild(renderer.domElement);

            // CONTROLS SETUP
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 5;
                controls.maxDistance = 50;
            } else {
                console.warn("OrbitControls not found. Camera movement is static.");
            }

            // LIGHTING
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 5);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // DRAW GRID BASE
            const floorGeometry = new THREE.PlaneGeometry(width, height);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.05;
            scene.add(floor);

            // Draw Grid Lines
            const gridHelper = new THREE.GridHelper(width, GRID_SIZE, 0xaaaaaa, 0xaaaaaa);
            scene.add(gridHelper);

            // ANIMATION LOOP
            const animate = () => {
              requestAnimationFrame(animate);
              if (controls) controls.update();
              renderer.render(scene, camera);
            };
            animate();

            // RESIZE HANDLER
            window.addEventListener('resize', () => {
                if (!mount) return;
                camera.aspect = mount.clientWidth / mount.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(mount.clientWidth, mount.clientHeight);
            });
        }

        function updateThreeDViewer() {
            if (typeof THREE === 'undefined' || !scene) return;

            // Collect keys for all elements that are NOT AGVs or AGV Cargo/Stacks
            const keysToClear = [];
            elementsRef.forEach((_, key) => {
                if (!key.startsWith('AGV_') && !key.startsWith('CARGO_') && !key.startsWith('STACK_') && !key.startsWith('DROPOFF_STACKS_')) {
                    keysToClear.push(key);
                }
            });

            // Clear old map elements (bases/platforms)
            keysToClear.forEach(key => removeAndDispose(key));

            // 1. Draw Grid Elements (Obstacles, Pickups, Dropoffs, Starts)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const type = grid[y][x];
                    const typeInfo = Object.values(CELL_TYPE).find(t => t.type === type);
                    const worldPos = toWorld(x, y);

                    let mesh = null;
                    let key = `${x}-${y}`;

                    if (type === CELL_TYPE.OBSTACLE.type) {
                        const geometry = new THREE.BoxGeometry(CELL_SIZE, 1, CELL_SIZE);
                        const material = new THREE.MeshLambertMaterial({ color: typeInfo.color });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(worldPos.x, 0.5, worldPos.z);
                    }
                    else if (type === CELL_TYPE.START.type || type === CELL_TYPE.PICKUP.type || type === CELL_TYPE.DROPOFF.type) {
                        // Base platform for Start/Pickup/Dropoff
                        let geometry = new THREE.BoxGeometry(CELL_SIZE, 0.1, CELL_SIZE);
                        let material = new THREE.MeshLambertMaterial({ color: typeInfo.color });
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(worldPos.x, 0.05, worldPos.z);

                        if (type === CELL_TYPE.START.type) {
                            // Simple visual cue for Start Zone (e.g., a small cone)
                             const coneGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
                             const coneMaterial = new THREE.MeshLambertMaterial({ color: typeInfo.color });
                             const coneMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                             coneMesh.position.set(worldPos.x, 0.25, worldPos.z);
                             scene.add(coneMesh);
                             elementsRef.set(`START_CUE_${key}`, coneMesh);
                        }
                    }

                    if (mesh) {
                      scene.add(mesh);
                      elementsRef.set(key, mesh);
                    }
                }
            }

            // 2. Update Pickup Stacks (Inventory)
            mapElements.pickups.forEach(pickup => {
                const stackKey = `STACK_${pickup.x}-${pickup.y}`;
                removeAndDispose(stackKey); // Remove old stack group

                if (pickup.productsRemaining > 0) {
                    const stackGroup = new THREE.Group();
                    const productGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.8, PRODUCT_HEIGHT, CELL_SIZE * 0.8);
                    const productMaterial = new THREE.MeshLambertMaterial({ color: 0x3333ff });
                    const worldPos = toWorld(pickup.x, pickup.y);

                    for(let i = 0; i < pickup.productsRemaining; i++) {
                        const productMesh = new THREE.Mesh(productGeometry, productMaterial);
                        // Start height above the 0.1 height base platform
                        productMesh.position.set(0, 0.05 + PRODUCT_HEIGHT / 2 + (i * PRODUCT_HEIGHT), 0);
                        stackGroup.add(productMesh);
                    }
                    stackGroup.position.set(worldPos.x, 0, worldPos.z); // Group origin is 0,0,0
                    scene.add(stackGroup);
                    elementsRef.set(stackKey, stackGroup);
                }
            });

            // 3. Update Dropoff Stacks (Production)
            mapElements.dropoffs.forEach(dropoff => {
                const dropoffKey = `DROPOFF_STACKS_${dropoff.x}-${dropoff.y}`;
                removeAndDispose(dropoffKey); // Remove old stack group

                let totalCount = dropoff.stacks.reduce((sum, stack) => sum + stack.count, 0);

                if (totalCount > 0) {
                    const stackGroup = new THREE.Group();
                    const productGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.8, PRODUCT_HEIGHT, CELL_SIZE * 0.8);
                    const productMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown for processed goods
                    const worldPos = toWorld(dropoff.x, dropoff.y);

                    for(let i = 0; i < totalCount; i++) {
                        const productMesh = new THREE.Mesh(productGeometry, productMaterial);
                        // Start height above the 0.1 height base platform
                        productMesh.position.set(0, 0.05 + PRODUCT_HEIGHT / 2 + (i * PRODUCT_HEIGHT), 0);
                        stackGroup.add(productMesh);
                    }
                    stackGroup.position.set(worldPos.x, 0, worldPos.z);
                    scene.add(stackGroup);
                    elementsRef.set(dropoffKey, stackGroup);
                }
            });


            // 4. Update AGVs
            agvs.forEach(agv => {
              let agvMesh = elementsRef.get(`AGV_${agv.id}`);
              const worldPos = toWorld(agv.x, agv.y);
              let color = AGV_COLOR.moving;
              if (agv.hasCargo) color = AGV_COLOR.cargo;
              if (agv.isWaiting) color = AGV_COLOR.waiting;

              if (!agvMesh) {
                // Create new AGV mesh
                const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.6, AGV_HEIGHT, CELL_SIZE * 0.6);
                const material = new THREE.MeshLambertMaterial({ color: color });
                agvMesh = new THREE.Mesh(geometry, material);
                agvMesh.position.set(worldPos.x, AGV_HEIGHT / 2, worldPos.z);
                scene.add(agvMesh);
                elementsRef.set(`AGV_${agv.id}`, agvMesh);
              } else {
                // Update existing AGV position and color (simple LERP for smoothness)
                agvMesh.material.color.setHex(color);
                const targetPos = new THREE.Vector3(worldPos.x, AGV_HEIGHT / 2, worldPos.z);
                agvMesh.position.lerp(targetPos, 0.2);
              }

              // Update Cargo visualization
              let cargoKey = `CARGO_${agv.id}`;
              let cargoMesh = elementsRef.get(cargoKey);
              if (agv.hasCargo && !cargoMesh) {
                const cargoGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.4, PRODUCT_HEIGHT, CELL_SIZE * 0.4);
                const cargoMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                cargoMesh = new THREE.Mesh(cargoGeometry, cargoMaterial);
                scene.add(cargoMesh);
                elementsRef.set(cargoKey, cargoMesh);
              } else if (agv.hasCargo && cargoMesh) {
                // Position cargo above the AGV
                cargoMesh.position.set(agvMesh.position.x, AGV_HEIGHT + PRODUCT_HEIGHT / 2, agvMesh.position.z);
              } else if (!agv.hasCargo && cargoMesh) {
                removeAndDispose(cargoKey);
              }
            });
        }

        // --- Simulation Core Logic ---

        function assignNewTarget(agv, currentAgvs) {
            let target = null;
            let path = null;

            // Priority 1: Drop off cargo
            if (agv.hasCargo) {
              const availableDropoffs = mapElements.dropoffs.filter(d => {
                const totalUnits = d.stacks.reduce((sum, stack) => sum + stack.count, 0);
                return totalUnits < MAX_STACK_HEIGHT;
              });

              if (availableDropoffs.length > 0) {
                // Sort by closest dropoff
                availableDropoffs.sort((a, b) => heuristic(agv.x, agv.y, a.x, a.y) - heuristic(agv.x, agv.y, b.x, b.y));
                target = availableDropoffs[0];
              }
            }
            // Priority 2: Go to pickup
            else {
              const availablePickups = mapElements.pickups.filter(p => p.productsRemaining > 0);

              if (availablePickups.length > 0) {
                // Sort by closest pickup
                availablePickups.sort((a, b) => heuristic(agv.x, agv.y, a.x, a.y) - heuristic(agv.x, agv.y, b.x, b.b));
                target = availablePickups[0];
              }
            }

            if (target) {
              // Note: We pass the *nextAgvs* state for collision avoidance in the pathfinding step
              path = aStar(agv.x, agv.y, target.x, target.y, grid, currentAgvs);
            }

            return {
              path: path || [],
              targetX: target ? target.x : agv.x,
              targetY: target ? target.y : agv.y
            };
        }

        function runSimulationStep() {
            if (agvs.length === 0) {
                stopSimulation();
                updateUI();
                return;
            }

            let nextAgvs = agvs.map(agv => ({ ...agv }));

            // Deep copy mapElements for mutable updates during the step
            let updatedMapElements = {
                starts: [...mapElements.starts],
                pickups: mapElements.pickups.map(p => ({...p})),
                dropoffs: mapElements.dropoffs.map(d => ({...d, stacks: d.stacks.map(s => ({...s}))}))
            };

            nextAgvs.forEach(agv => {

                // Phase 1: Target Assignment / Path Generation
                if (agv.path.length === 0) {
                  // Pass nextAgvs (the state of AGVs *before* this AGV moves) for better collision avoidance logic
                  const { path, targetX, targetY } = assignNewTarget(agv, nextAgvs);
                  agv.path = path;
                  agv.targetX = targetX;
                  agv.targetY = targetY;
                }

                // Phase 2: Movement & Collision Avoidance
                if (agv.path.length > 0) {
                  const nextStep = agv.path[0];

                  // Simple collision check: does the next step already contain another AGV in its *planned* next position?
                  const willCollide = nextAgvs.some(otherAgv =>
                    otherAgv.id !== agv.id &&
                    otherAgv.x === nextStep.x &&
                    otherAgv.y === nextStep.y
                  );

                  if (agv.isWaiting && !willCollide) {
                      agv.isWaiting = false;
                  }

                  if (!agv.isWaiting && !willCollide) {
                    // Move one step
                    agv.x = nextStep.x;
                    agv.y = nextStep.y;
                    agv.path.shift();
                  } else if (willCollide) {
                    // Stop and wait for the next cell
                    agv.isWaiting = true;
                  }
                }

                // Phase 3: Action Execution (Arrived at target)
                if (agv.path.length === 0 && agv.x === agv.targetX && agv.y === agv.targetY) {
                    agv.isWaiting = false;

                    if (agv.hasCargo) {
                        // DROP OFF CARGO
                        const dropoff = updatedMapElements.dropoffs.find(d => d.x === agv.x && d.y === agv.y);
                        if (dropoff) {
                            // Deposit product into the first non-full stack
                            if (dropoff.stacks[0].count < MAX_STACK_HEIGHT) {
                                dropoff.stacks[0].count += 1;
                                dropoff.productionCount += 1;
                                agv.hasCargo = false;
                                // No need to update opcUaTags directly here, it's done outside the loop
                            }
                        }

                    } else {
                        // PICK UP CARGO
                        const pickup = updatedMapElements.pickups.find(p => p.x === agv.x && p.y === agv.y);
                        if (pickup) {
                            if (pickup.productsRemaining > 0) {
                                pickup.productsRemaining -= 1;
                                agv.hasCargo = true;
                                // No need to update opcUaTags directly here, it's done outside the loop
                            }
                        }
                    }
                }
            });

            // Update global state
            agvs = nextAgvs;
            mapElements = updatedMapElements;

            opcUaTags.AGV_STATUS_COUNT = agvs.length;
            opcUaTags.WAREHOUSE_INVENTORY_LEVEL = updatedMapElements.pickups.reduce((sum, p) => sum + p.productsRemaining, 0);
            opcUaTags.TOTAL_PRODUCTION_COUNT = updatedMapElements.dropoffs.reduce((sum, d) => sum + d.productionCount, 0);
            opcUaTags.SIM_TIMESTAMP = new Date().toLocaleTimeString();

            updateThreeDViewer();
            updateUI(); // Re-render 2D grid and status
        }

        // --- Simulation Controls ---

        function startSimulation(speed) {
            if (simIntervalId) clearInterval(simIntervalId);
            isRunning = true;
            document.getElementById('toggle-sim-btn').textContent = '⏸ Pause Simulation';
            document.getElementById('toggle-sim-btn').classList.replace('bg-green-500', 'bg-orange-500');
            document.getElementById('toggle-sim-btn').classList.replace('hover:bg-green-600', 'hover:bg-orange-600');

            simIntervalId = setInterval(runSimulationStep, speed || settings.speed);
        }

        function stopSimulation() {
            if (simIntervalId) clearInterval(simIntervalId);
            simIntervalId = null;
            isRunning = false;
            document.getElementById('toggle-sim-btn').textContent = '▶ Run Simulation';
            document.getElementById('toggle-sim-btn').classList.replace('bg-orange-500', 'bg-green-500');
            document.getElementById('toggle-sim-btn').classList.replace('hover:bg-orange-600', 'hover:bg-green-600');
        }

        function toggleSimulation() {
            if (isRunning) {
                stopSimulation();
            } else {
                startSimulation(settings.speed);
            }
            updateUI();
        }

        function spawnAllAGVs() {
            stopSimulation();

            // Remove all existing AGV meshes from the scene
            agvs.forEach(agv => {
                removeAndDispose(`AGV_${agv.id}`);
                removeAndDispose(`CARGO_${agv.id}`);
            });

            agvs = [];
            agvCounter = 0;

            mapElements.starts.forEach(start => {
              agvCounter++;
              agvs.push({
                id: agvCounter,
                x: start.x,
                y: start.y,
                path: [],
                hasCargo: false,
                isWaiting: false,
                targetX: start.x,
                targetY: start.y,
              });
            });

            if (agvs.length > 0) {
              startSimulation(settings.speed);
            } else {
                stopSimulation();
            }
            updateUI();
        }

        // --- Grid and Placement Logic ---

        function handleGridClick(x, y) {
            const selectedTypeInfo = CELL_TYPE[settings.placementType];
            const newType = selectedTypeInfo.type;
            const isOccupied = agvs.some(agv => agv.x === x && agv.y === y);

            if (isOccupied && newType !== CELL_TYPE.PATH.type) {
              return;
            }

            // 1. Update Map Elements State
            const originalType = grid[y][x];

            // Remove old element at that spot
            if (originalType === CELL_TYPE.START.type) {
                mapElements.starts = mapElements.starts.filter(p => p.x !== x || p.y !== y);
            } else if (originalType === CELL_TYPE.PICKUP.type) {
                mapElements.pickups = mapElements.pickups.filter(p => p.x !== x || p.y !== y);
            } else if (originalType === CELL_TYPE.DROPOFF.type) {
                // FIXED: was mapElements.dropoffs.dropoffs
                mapElements.dropoffs = mapElements.dropoffs.filter(p => p.x !== x || p.y !== y);
            }

            // Add new element if it's not PATH
            if (newType === CELL_TYPE.START.type) {
                mapElements.starts = [...mapElements.starts, { x, y }];
            } else if (newType === CELL_TYPE.PICKUP.type) {
                if (!mapElements.pickups.some(p => p.x === x && p.y === y)) {
                  mapElements.pickups = [...mapElements.pickups, { x, y, productsRemaining: MAX_STACK_HEIGHT }];
                }
            } else if (newType === CELL_TYPE.DROPOFF.type) {
                if (!mapElements.dropoffs.some(p => p.x === x && p.y === y)) {
                  const initialStacks = [{ count: 0, spotIndex: 0 }];
                  mapElements.dropoffs = [...mapElements.dropoffs, { x, y, stacks: initialStacks, productionCount: 0 }];
                }
            }

            // 2. Update Grid State
            grid[y][x] = newType;

            updateThreeDViewer();
            updateUI();
        }

        // --- UI Update Function (Replaces React Re-render) ---

        function updateUI() {
            // 1. Render 2D Grid Cells
            const gridContainer = document.getElementById('grid-container');
            gridContainer.innerHTML = '';

            grid.forEach((row, y) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = "flex flex-row";

                row.forEach((cellType, x) => {
                    const typeInfo = Object.values(CELL_TYPE).find(t => t.type === cellType);
                    const agvPresent = agvs.find(agv => agv.x === x && agv.y === y);
                    const isTarget = agvs.find(agv => agv.targetX === x && agv.targetY === y);

                    const cellDiv = document.createElement('div');
                    cellDiv.className = `w-[2.5vh] h-[2.5vh] sm:w-8 sm:h-8 border border-gray-300 transition-colors duration-100 flex items-center justify-center cursor-pointer text-xs font-bold ${typeInfo.class}`;
                    cellDiv.onclick = () => handleGridClick(x, y);

                    let content = '';
                    if (agvPresent) {
                         const colorClass = agvPresent.hasCargo ? 'text-amber-700' : 'text-green-700';
                         content = `<span class="text-xl ${colorClass}">${agvPresent.hasCargo ? '🚚' : '⚙️'}</span>`;
                    } else {
                         // Only render the icon if it's not the empty PATH icon
                         if (typeInfo.icon) {
                            const ringClass = isTarget ? 'ring-2 ring-offset-2 ring-indigo-500 rounded-full' : '';
                            content = `<span class="text-lg ${ringClass}">${typeInfo.icon}</span>`;
                         }
                    }
                    cellDiv.innerHTML = content;
                    rowDiv.appendChild(cellDiv);
                });
                gridContainer.appendChild(rowDiv);
            });

            // 2. Update Stats Panel
            document.getElementById('stat-agv-count').textContent = opcUaTags.AGV_STATUS_COUNT;
            document.getElementById('stat-inventory').textContent = opcUaTags.WAREHOUSE_INVENTORY_LEVEL;
            document.getElementById('stat-production').textContent = opcUaTags.TOTAL_PRODUCTION_COUNT;
            document.getElementById('stat-timestamp').textContent = opcUaTags.SIM_TIMESTAMP;
            document.getElementById('agv-count-status').textContent = agvs.length;

            // 3. Update AGV Status List
            const statusList = document.getElementById('agv-status-list');
            statusList.innerHTML = '';

            if (agvs.length === 0) {
                statusList.innerHTML = '<p class="text-sm text-gray-500 italic">Spawn AGVs at \'Start\' locations to begin tracking.</p>';
            } else {
                agvs.forEach(agv => {
                    const statusDiv = document.createElement('div');
                    statusDiv.className = "text-xs p-2 bg-white rounded-lg shadow-sm";

                    const cargoStatus = agv.hasCargo
                        ? `<span class="text-amber-700">Carrying 📦</span>`
                        : `<span class="text-green-600">Empty</span>`;

                    const waitStatus = agv.isWaiting
                        ? `<span class="ml-2 text-red-500 font-bold">WAITING</span>`
                        : '';

                    statusDiv.innerHTML = `
                        <span class="font-bold text-gray-800">AGV ${agv.id}: </span>
                        ${cargoStatus}
                        <span class="ml-2 text-gray-500">
                            (${agv.x},${agv.y}) &rarr; (${agv.targetX},${agv.targetY})
                        </span>
                        ${waitStatus}
                    `;
                    statusList.appendChild(statusDiv);
                });
            }

            // 4. Update Button States
            document.getElementById('spawn-agvs-btn').disabled = mapElements.starts.length === 0 || isRunning;
            document.getElementById('toggle-sim-btn').disabled = agvs.length === 0;
            document.getElementById('spawn-agvs-btn').textContent = `Spawn ${mapElements.starts.length} AGV(s)`;

            // 5. Update Speed Slider
            document.getElementById('speed-value').textContent = `${settings.speed}ms`;
        }

        // --- Initialization on Load ---
        window.onload = function() {
            // Firebase Auth Setup (included for Canvas environment compliance)
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
            if (firebaseConfig) {
              const app = initializeApp(firebaseConfig);
              const auth = getAuth(app);
              const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

              const setupAuth = async () => {
                  try {
                      if (initialAuthToken) {
                          await signInWithCustomToken(auth, initialAuthToken);
                      } else {
                          await signInAnonymously(auth);
                      }
                  } catch (e) {
                      console.error("Firebase Auth failed:", e);
                  }
              };
              setupAuth();
            }

            // Render Placement Selector Buttons
            const selectorDiv = document.getElementById('placement-selector');
            Object.keys(CELL_TYPE).forEach(key => {
                const typeInfo = CELL_TYPE[key];
                const button = document.createElement('button');

                button.textContent = `${typeInfo.icon} ${typeInfo.label}`;
                button.className = `p-2 rounded-lg text-sm font-semibold transition-all shadow-md bg-white text-gray-700 hover:bg-indigo-50 hover:ring-1 ring-indigo-200`;

                button.onclick = () => {
                    settings.placementType = key;
                    // Visually update buttons (basic way)
                    Array.from(selectorDiv.children).forEach(btn => {
                        btn.classList.remove('bg-indigo-600', 'text-white', 'ring-2', 'ring-indigo-300');
                        btn.classList.add('bg-white', 'text-gray-700');
                    });
                    button.classList.add('bg-indigo-600', 'text-white', 'ring-2', 'ring-indigo-300');
                    button.classList.remove('bg-white', 'text-gray-700');
                };

                if (key === settings.placementType) {
                     button.classList.add('bg-indigo-600', 'text-white', 'ring-2', 'ring-indigo-300');
                     button.classList.remove('bg-white', 'text-gray-700');
                }
                selectorDiv.appendChild(button);
            });

            // Add Event Listeners
            document.getElementById('spawn-agvs-btn').onclick = spawnAllAGVs;
            document.getElementById('toggle-sim-btn').onclick = toggleSimulation;

            const speedSlider = document.getElementById('speed-slider');
            speedSlider.oninput = (e) => {
                const newSpeed = parseInt(e.target.value);
                settings.speed = newSpeed;
                if (isRunning) startSimulation(newSpeed);
                updateUI();
            };

            // Initialize 3D and 2D UIs
            initThreeDViewer();
            updateUI();
        };
    </script>
</body>

</html>
